---
title: "HGWR Model and How to Use It"
author: "Yigong Hu"
date: '2022-05-16'
output:
  rmdformats::readthedown:
    self_contained: false
    css: "style.css"
    toc_depth: 3
    df_print: kable
bibliography: references.bib
link-citations: true
---

A brief tutorial to Hierarchical and Geographically Weighted Regression model and **hgwrr** package in R.

## Introduction to HGWR Model

### What is HGWR model?

Hierarchical and Geographically Weighted Regression, shorted for HGWR,
is a spatial modelling method designed for data of spatial hierarchical structures.
Just as its name implies, this is a combination of Hierarchical Linear Model
[HLM, also known as Multilevel Model, @Raudenbush-1993]
and Geographically Weighted Regression [GWR, @BrunsdonFotheringham-1996].
In this model, spatial effects are divided into three types: global fixed, local fixed and random.
Formally, it is expressed as
$$
y = G\gamma + X\beta + Z\mu + \epsilon
$$
with $y$ the dependent variable,
$G$ the group level independent variables, $\gamma$ the local fixed effects,
$X$ also the group level independent variables, $\beta$ the global fixed effects,
$Z$ the individual level independent variables, $\mu$ the random effects,
$\epsilon$ the individual errors.

### Why HLGWR model?

As we know, hierarchical structure is commonly existing in spatial data.
For example, cities can be grouped by provinces or other higher-level administrative district they belong to;
house prices may share some factors from the block;
and students in one school have different access to education resources with those in another school.
When dealing with this type of data, we usually choose HLM to address the within-group homogeneity and the between-group heterogeneity.
And there are usually two types of variables: group-level variables and sample-level variables.
The formal ones are used to describe the properties of groups
(such as the provinces, blocks and schools);
the latter ones are observations of individual samples
(such as the cities, houses and students).
The effect of some sample-level variables are similar in all groups,
thus they are modelled with fixed coefficients (effects).
For others, they are modelled individually, i.e., with random effects.

However, for group-level variables, they can only be modelled with fixed effects.
For spatial data, we would encounter some problems.
According to the Tobler's first law of Geography "Everything is related to everything else, but near things are more related than distant things" [@Tobler-1970].
If the model is calibrated with equally weighted samples, spatial heterogeneity would be overlooked [@FotheringhamBrunsdon-2002].
Thus, it requires us to distinguish "local fixed effects" from "global fixed effects" to discover spatial heterogeneity in group-level variables.

But why not GWR or Multiscale GWR [@FotheringhamYang-2017, LuBrunsdon-2017]
Because when dealing with data of hierarchical structures, GWR is problematic [@HuLu-2022].
We know that GWR calibrate a model with unique coefficients on each sample by borrowing data from its neighbours.
And it uses a parameter "bandwidth" to control how many neighbours are included.
If samples are not hierarchically structured, everything works well.
However, just imagine a situation like Figure 1.
For the two samples of red color and blue color,
we take the same number of their neighbours,
but actually the spatial extents are not the same.
In extreme cases, spatial extends of some samples could be too small to hold more than one or two location, but some are large enough.
This would lead to the failure of bandwidth optimization and reduce the reliability of the optimized bandwidth.

<video autoplay muted controls>
  <source src="assets/multisampling.mp4" type="video/mp4">
</video>

> As shown in this video, bandwidths have inequal spatial scale for two samples (represented by cubes).
> Both the samples represented by large red cubes and large blue cubes take 41 neighbour samples to calibrate GWR models. 
> For the red one, neighbours on 8 nearest locations are taken. 
> But the figure for the blue one is only 6.
> This situation means estimated coefficients are more smoothed for the red samples.
> In other words, estimations for the blue samples are much local.

To solve the problems mentioned above, we need to use HGWR model.
It is able to modelling spatial hierarchical structure and spatial heterogeneity simultaneously.
Examples below can show that it works well for spatial hierarchical data.

## Modelling with HGWR Model

The R package **hgwrr** is built for calibrating HGWR model.
In this section, we are going to show how to use it.

### Installation

Package **hgwrr** will be available on CRAN soon.
Simply type the following codes to install it.

```r
install.packages("hgwrr")
```

Or download [latest released source package](https://github.com/HPDell/hlmgwr-backfitting-ml/releases/download/v0.2.0-r2/hgwrr_0.2-0.tar.gz)
and run the following command to install this package.

```bash
R CMD INSTALL hgwrr_0.2-0.tar.gz
```

Note that [RTools](https://cran.r-project.org/bin/windows/Rtools/) is required on Windows.

### Usage

We are going to show the usage of **hgwrr** package with a simulated data.

First, we need to load this package in an R session.

```{r}
library(hgwrr)
```

Then we can calibrate an HGWR model via `hgwr()` function.

```r
hgwr(
  formula, data, local.fixed, coords, bw,
  alpha = 0.01, eps_iter = 1e-06, eps_gradient = 1e-06, max_iters = 1e+06,
  max_retries = 10, ml_type = HGWR_ML_TYPE_D_ONLY, verbose = 0
)
```

The first five arguments are mandatory.

- `formula` accepts a formula object in R. Its format follows **lme4** package.
  As there are two types of effects: fixed effects and random effects,
  we use the following format to specify both of them:

    ```r
    dependent ~ fixed1 + fixed2 + (random1 + random2 | group)
    ```

- `data` accepts a DataFrame object in R.
  All variables specified in `formula` are extracted from `data`.
  In this stage, `Spatial*DataFrame` is not supported.
- `local.fixed` accepts a list of character specifying which fixed effects are local.
  For example, if `fixed1` needs to be local fixed, then set `local.fixed` to `c("fixed1")`.
- `coords` accepts a matrix of 2 columns. Each row is the longitude and latitude of each group.
- `bw` accepts a integer or numeric number to specify the bandwidth used in geographically weighted process.
  Currently it can only be adaptive bandwidth.

Other arguments are optional which is used to control the backfitting maximum likelihood algorithm.
On most occassions the default values are fine.
If the default values cause some problems and you want change some of them,
please check the documentation of function `hgwr()` for more infomation.

### Example: A Small Simulated Data Set

*This example is used to show the usage of this package and to test whether it works.
We don't care about how good the fitness of this model is with this data set.*

A data set "multisampling" is provided with this package,

```{r}
data(multisampling)
head(multisampling$data)
head(multisampling$coord)
```

where `y` is the dependent variable,
`g1` and `g2` are two group-level variables,
`z1` and `x1` are two sample-level variables,
`group` are the labels of the groups they belong to,
and `U`, `V` are longitude and latitude coordinate values of all groups.

We regards `g1` and `g2` have local fixed effects, `x1` have global fixed effects and `z1` have random effects.
Then we can calibrate an HGWR model with like this

```{r, cache=T}
model1 <- hgwr(
  formula = y ~ g1 + g2 + x1 + (z1 | group),
  data = multisampling$data,
  local.fixed = c("g1", "g2"),
  coords = multisampling$coord,
  bw = 10
)
model1
```

The output of the model shows estimations of global fixed effects,
summary of those of local fixed effects.
Also there are the standard deviations of random effects and correlation coefficients between them.

Then we can have a look on the coefficient estimations.

```{r}
coef(model1)
```

With **ggplot2** or other packages, we can create some figures.

```{r}
library(ggplot2)
model1_coef_coord <- as.data.frame(cbind(multisampling$coord, coef(model1)))
ggplot(model1_coef_coord, aes(x = U, y = V)) + 
  geom_point(aes(color = g1))
```

We can also convert it to spatial data and use **tmap** to visualize.

```{r}
library(sf)
library(tmap)
model1_coef_coord_sf <- st_as_sf(model1_coef_coord,
                                 coords = names(multisampling$coord),
                                 crs = 27700)
tm_shape(model1_coef_coord_sf) + tm_dots(col = c("g1", "g2"), size = 0.5)
```

And we can also fetch the fitted and residuals.

```{r}
head(data.frame(
  real = multisampling$data$y,
  fitted = fitted(model1),
  residuals = residuals(model1)
))
```

The `summary()` function will give some statistical information about this model.

```{r}
summary(model1)
```

On the current stage, only pesudo $R^2$ is available.
In the future, more diagnostic information will be provided in this package.

## References
